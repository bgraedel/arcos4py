"""Module to plot different metrics generated by arcos4py functions.

Examples:
    >>> # Data Plots
    >>> from arcos4py.plotting import dataPlots
    >>> data_plots = dataPlots(df,'time', 'meas', 'track_id')
    >>> hist = data_plots.histogram()
    >>> dens = data_plots.density_plot()
    >>> xt_plot = data_plots.position_t_plot({'x'}, n=20)

    >>> # Detrended vs original plot
    >>> from arcos4py.plotting import plotOriginalDetrended
    >>> arcosPlots = plotOriginalDetrended(data, 'time', 'meas', 'detrended', 'id')
    >>> plot = arcosPlots(data, 'time', 'meas', 'detrended', 'id')
    >>> plot.plot_detrended()

    >>> # Stats Plot
    >>> from arcos4py.plotting import statsPlots
    >>> coll_dur_size_scatter = statsPlots(stats).plot_events_duration('total_size','duration')

    >>> # Noodle Plot
    >>> from arcos4py.plotting import NoodlePlot
    >>> ndl = NoodlePlot(df,"collid", 'track_id', 'time', 'x', 'y')
    >>> ndl_plot = ndl.plot('x')
"""

from __future__ import annotations

import colorsys
import logging
from collections import defaultdict
from typing import Any, Dict, List, Set, Tuple, Union

import matplotlib.patches as patches
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.path import Path
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.spatial.distance import squareform

from ..tools._arcos4py_deprecation import handle_deprecated_params

logging.basicConfig(level=logging.INFO)

TAB20 = [
    "#1f77b4",
    "#aec7e8",
    "#ff7f0e",
    "#ffbb78",
    "#2ca02c",
    "#98df8a",
    "#d62728",
    "#ff9896",
    "#9467bd",
    "#c5b0d5",
    "#8c564b",
    "#c49c94",
    "#e377c2",
    "#f7b6d2",
    "#7f7f7f",
    "#c7c7c7",
    "#bcbd22",
    "#dbdb8d",
    "#17becf",
    "#9edae5",
]


class dataPlots:
    """Plot different metrics of input data.

    Attributes:
        data (Dataframe): containing ARCOS data.
        frame_column (str): name of frame column in data.
        measurement_column (str): name of measurement column in data.
        obj_id_column (str): name of track id column.
    """

    def __init__(
        self,
        data: pd.DataFrame,
        frame_column: str = 'frame',
        measurement_column: str = 'm',
        obj_id_column: str = 'obj_id',
        **kwargs,
    ):
        """Plot different metrics such as histogram, position-t and density.

        Arguments:
            data (Dataframe): containing ARCOS data.
            frame_column (str): name of frame column in data.
            measurement_column (str): name of measurement column in data.
            obj_id_column (str): name of track id column.
            **kwargs (Any): Additional keyword arguments. Includes deprecated parameters.
                - id (str): Deprecated. Use obj_id_column instead.
                - frame (str): Deprecated. Use frame_column instead.
                - measurement (str): Deprecated. Use measurement_column instead.
        """
        map_deprecated_params = {
            "id": "obj_id_column",
            "frame": "frame_column",
            "measurement": "measurement_column",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        obj_id_column = updated_kwargs.get("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.get("frame_column", frame_column)
        measurement_column = updated_kwargs.get("measurement_column", measurement_column)

        self.data = data
        self.obj_id = obj_id_column
        self.frame_column = frame_column
        self.measurement_column = measurement_column

    def position_t_plot(self, position_columns: set[str] = {'x'}, n: int = 20, **kwargs) -> Union[plt.Figure, Any]:
        """Plots X and Y over T to visualize tracklength.

        Arguments:
            position_columns (set): containing names of position columns in data.
            n (int): number of samples to plot.
            **kwargs (Any): Additional keyword arguments. Includes deprecated parameters.
                - posCol (set): Deprecated. Use position_columns instead.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of density plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of density plot.
        """
        map_deprecated_params = {
            "posCol": "position_columns",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        position_columns = updated_kwargs.get("position_columns", position_columns)

        sample = pd.Series(self.data[self.obj_id].unique()).sample(n)
        pd_from_r_df = self.data.loc[self.data[self.obj_id].isin(sample)]
        fig, axes = plt.subplots(1, len(position_columns), figsize=(6, 3))
        for _, df in pd_from_r_df.groupby(self.obj_id):
            for index, value in enumerate(position_columns):
                if len(position_columns) > 1:
                    df.plot(x=self.frame_column, y=value, ax=axes[index], legend=None)
                else:
                    df.plot(x=self.frame_column, y=value, ax=axes, legend=None)
        if len(position_columns) > 1:
            for index, value in enumerate(position_columns):
                axes[index].set_title(value)
        else:
            axes.set_title(value)
        return fig, axes

    def density_plot(self, *args, **kwargs):
        """Density plot of measurement.

        Uses Seaborn distplot to plot measurement density.

        Arguments:
            *args (Any): arguments passed on to seaborn histplot function.
            **kwargs (Any): keyword arguments passed on to seaborn histplot function.

        Returns:
            FacetGrid (seaborn.FacetGrid): Seaborn FacetGrid of density density plot.
        """
        plot = sns.displot(
            self.data[self.measurement_column],
            kind="kde",
            palette="pastel",
            label=self.measurement_column,
            *args,
            **kwargs,
        )
        # Plot formatting
        plt.legend(prop={'size': 10})
        plt.title('Density Plot of Measurement')
        plt.xlabel('Measurement')
        plt.ylabel('Density')
        return plot

    def histogram(self, bins: str = 'auto', *args, **kwargs) -> plt.Axes:
        """Histogram of tracklenght.

        Uses seaborn histplot function to plot tracklenght histogram.

        Arguments:
            bins (str): number or width of bins in histogram
            *args (Any): arguments passed on to seaborn histplot function.
            **kwargs (Any): keyword arguments passed on to seaborn histplot function.

        Returns:
            AxesSubplot: Matplotlib AxesSubplot of histogram.
        """
        # Draw histogram
        track_length = self.data.groupby(self.obj_id).size()
        axes = sns.histplot(track_length, label="Track Length", bins=bins, *args, **kwargs)
        # Plot formatting
        plt.title('Track length Histogram')
        axes.set_xlabel('Track Length')
        axes.set_ylabel('Count')
        return axes


class plotOriginalDetrended:
    """Plot original and detrended data.

    Attributes:
        data (DataFrame): containing ARCOS data.
        frame_column (str): name of frame column in data.
        measurement_column (str): name of measurement column in data.
        detrended_column (str): name of detrended column in data.
        obj_id_column (str): name of track id column.
        seed (int): seed for random number generator.

    Methods:
        plot_detrended: plot detrended data.
        plot_original: plot original data.
        plot_original_and_detrended: plot original and detrended data.
    """

    def __init__(
        self,
        data: pd.DataFrame,
        frame_column: str = "frame",
        measurement_column: str = "m",
        detrended_column: str = "m_detrended",
        obj_id_column: str = "obj_id",
        seed: int = 42,
        **kwargs,
    ):
        """Constructs class with given parameters."""
        map_deprecated_params = {
            "id": "obj_id_column",
            "frame": "frame_column",
            "detrended": "detrended_column",
            "measurement": "measurement_column",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        obj_id_column = updated_kwargs.get("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.get("frame_column", frame_column)
        measurement_column = updated_kwargs.get("measurement_column", measurement_column)

        self.data = data
        self.frame_column = frame_column
        self.measurement_column = measurement_column
        self.detrended_column = detrended_column
        self.obj_id_column = obj_id_column
        self.seed = seed

    def _prepare_data(self, n_samples: int):
        rng_gen = np.random.default_rng(seed=self.seed)
        vals = rng_gen.choice(self.data[self.obj_id_column].unique(), n_samples, replace=False)  # noqa: F841
        filtered_data = self.data.query(f"{self.obj_id_column} in @vals")
        return filtered_data.groupby(self.obj_id_column)

    def _plot_data(self, grouped, ncols, nrows, plotsize, plot_columns, labels, add_binary_segments=False):
        fig, axes2d = plt.subplots(nrows=nrows, ncols=ncols, figsize=plotsize, sharey=True)
        max_val = 0
        for (name, group), ax in zip(grouped, axes2d.flatten()):
            for column, label in zip(plot_columns, labels):
                ax.plot(group[self.frame_column], group[column], label=label)
                max_val = group[column].max() if group[column].max() > max_val else max_val
            ax.set_title(f"Track {name}")

        if add_binary_segments:
            for (name, group), ax in zip(grouped, axes2d.flatten()):
                self._add_binary_segments(group, ax, max_val)

        fig.supxlabel('Time Point')
        fig.supylabel('Measurement')
        handles, labels = ax.get_legend_handles_labels()
        fig.tight_layout()
        fig.legend(handles, labels, loc='upper right')

        return fig, axes2d

    def _add_binary_segments(self, group, ax, max_val):
        x_val = group[group[f"{self.measurement_column}.bin"] != 0][self.frame_column]
        y_val = np.repeat(max_val, x_val.size)
        indices = np.where(np.diff(x_val) != 1)[0] + 1
        x_split = np.split(x_val, indices)
        y_split = np.split(y_val, indices)
        for idx, (x_val, y_val) in enumerate(zip(x_split, y_split)):
            if idx == 0:
                ax.plot(x_val, y_val, color="red", lw=2, label="bin")
            else:
                ax.plot(x_val, y_val, color="red", lw=2)

    def plot_detrended(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots detrended data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped, subplots[0], subplots[1], plotsize, [self.detrended_column], ["detrended"], add_binary_segments
        )

    def plot_original(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots original data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped,
            subplots[0],
            subplots[1],
            plotsize,
            [self.measurement_column],
            ["original"],
            add_binary_segments,
        )

    def plot_original_and_detrended(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots original and detrended data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped,
            subplots[0],
            subplots[1],
            plotsize,
            [self.measurement_column, self.detrended_column],
            ["original", "detrended"],
            add_binary_segments,
        )


class statsPlots:
    """Plot data generated by the stats module.

    Attributes:
        data (DataFrame): containing ARCOS stats data.
    """

    def __init__(self, data: pd.DataFrame):
        """Plot detrended vs original data.

        Arguments:
            data (DataFrame): containing ARCOS stats data.
        """
        self.data = data

    def plot_events_duration(self, total_size: str, duration: str, point_size: int = 40, *args, **kwargs) -> plt.Axes:
        """Scatterplot of collective event duration.

        Arguments:
            total_size (str): name of total size column.
            duration (str):, name of column with collective event duration.
            point_size (int): scatterplot point size.
            *args (Any): Arguments passed on to seaborn scatterplot function.
            **kwargs (Any): Keyword arguments passed on to seaborn scatterplot function.

        Returns:
            Axes (matplotlib.axes.Axes): Matplotlib Axes object of scatterplot
        """
        if self.data.empty:
            raise ValueError("Dataframe is empty")
        plot = sns.scatterplot(x=self.data[total_size], y=self.data[duration], s=point_size, *args, **kwargs)
        return plot


class NoodlePlot:
    """Create Noodle Plot of cell tracks, colored by collective event id.

    Attributes:
        df (pd.DataFrame): DataFrame containing collective events from arcos.
        colev (str): Name of the collective event column in df.
        trackid (str): Name of the track column in df.
        frame (str): Name of the frame column in df.
        posx (str): Name of the X coordinate column in df.
        posy (str): Name of the Y coordinate column in df.
        posz (str): Name of the Z coordinate column in df,
            or None if no z column.
    """

    def __init__(
        self,
        df: pd.DataFrame,
        clid_column: str = "collid",
        obj_id_column: str = "obj_id",
        frame_column: str = "frame",
        posx: str = "x",
        posy: str = "y",
        posz: Union[str, None] = None,
        **kwargs,
    ):
        """Constructs class with given parameters.

        Arguments:
            df (pd.DataFrame): DataFrame containing collective events from arcos.
            clid_column (str): Name of the collective event column in df.
            obj_id_column (str): Name of the track column in df.
            frame_column (str): Name of the frame column in df.
            posx (str): Name of the X coordinate column in df.
            posy (str): Name of the Y coordinate column in df.
            posz (str | None): Name of the Z coordinate column in df,
                or None if no z column.
            **kwargs (Any): Additional keyword arguments for plot. Includes deprecated parameters.
                - colev (str): Deprecated. Use clid_column instead.
                - trackid (str): Deprecated. Use obj_id_column instead.
                - frame (str): Deprecated. Use frame_column instead.
        """
        map_deprecated_params = {
            "colev": "clid_column",
            "trackid": "obj_id_column",
            "frame": "frame_column",
        }

        # allowed matplotlib kwargs
        allowed_kwargs = [
            "alpha",
            "animated",
            "c",
            "label",
            "linewidth",
            "linestyle",
            "marker",
            "markersize",
            "markeredgecolor",
            "markerfacecolor",
            "markerfacecoloralt",
            "markeredgewidth",
            "path_effects",
            "picker",
            "pickradius",
            "solid_capstyle",
            "solid_joinstyle",
            "transform",
            "visible",
            "zorder",
        ]

        # check allowed kwargs
        allowed_kwargs_2 = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs and key not in allowed_kwargs_2:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        clid_column = updated_kwargs.pop("clid_column", clid_column)
        obj_id_column = updated_kwargs.pop("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.pop("frame_column", frame_column)

        self.df = df
        self.clid_column = clid_column
        self.obj_id_column = obj_id_column
        self.frame_column = frame_column
        self.posx = posx
        self.posy = posy
        self.posz = posz
        self.plot_kwargs = updated_kwargs

    def _prepare_data_noodleplot(
        self,
        df: pd.DataFrame,
        color_cylce: list[str],
        clid_column: str,
        obj_id_column: str,
        frame_column: str,
        posx: str,
        posy: str,
        posz: Union[str, None] = None,
    ) -> tuple[list[np.ndarray], np.ndarray]:
        """From arcos collective event data,\
        generates a list of numpy arrays, one for each event.

        Arguments:
            df (pd.DataFrame): DataFrame containing collective events from arcos.
            color_cylce (list[str]): list of colors used to color trackid's
                for individual collective events.
            colev (str): Name of the collective event column in df.
            trackid (str): Name of the track column in df.
            frame: (str): Name of the frame column in df.
            posx (str): Name of the X coordinate column in df.
            posy (str): Name of the Y coordinate column in df.
            posz (str): Name of the Z coordinate column in df,
                or None if no z column.

        Returns:
            grouped_array (list[np.ndarray]): List of collective events data
            colors (np.ndarray): colors for each collective event.
        """
        df = df.copy()
        # factorize trackid to get unique values and make sure they are nummeric
        df[obj_id_column] = df[obj_id_column].factorize()[0]
        # sort by collective event and trackid
        df = df.sort_values([clid_column, obj_id_column])
        if posz:
            array = df[[clid_column, obj_id_column, frame_column, posx, posy, posz]].to_numpy()
        else:
            array = df[[clid_column, obj_id_column, frame_column, posx, posy]].to_numpy()
        # generate goroups for each unique value
        grouped_array = np.split(array, np.unique(array[:, 0], axis=0, return_index=True)[1][1:])
        # make collids sequential
        seq_colids = np.concatenate(
            [np.repeat(i, value.shape[0]) for i, value in enumerate(grouped_array)],
            axis=0,
        )
        array_seq_colids = np.column_stack((array, seq_colids))
        # split sequential collids array by trackid and collid
        grouped_array = np.split(
            array_seq_colids,
            np.unique(array_seq_colids[:, :2], axis=0, return_index=True)[1][1:],
        )
        # generate colors for each collective event, wrap arround the color cycle
        colors = np.take(np.array(color_cylce), [i + 1 for i in np.unique(seq_colids)], mode="wrap")
        return grouped_array, colors

    def _create_noodle_plot(self, grouped_data: list[np.ndarray], colors: np.ndarray):
        """Plots the noodle plot."""
        fig, ax = plt.subplots()
        ax.set_xlabel("Time Point")
        ax.set_ylabel("Position")
        for dat in grouped_data:
            if dat.size == 0:
                continue
            ax.plot(
                dat[:, 2],
                dat[:, self.projection_index],
                c=colors[int(dat[0, -1])],
                **self.plot_kwargs,
            )
        return fig, ax

    def plot(self, projection_axis: str, color_cylce: list[str] = TAB20):
        """Create Noodle Plot of cell tracks, colored by collective event id.

        Arguments:
            projection_axis (str): Specify with witch coordinate the noodle
                plot should be drawn. Has to be one of the posx, posy or posz arguments
                passed in during the class instantiation process.
            color_cylce (list[str]): List of hex color values or string names
                (i.e. ['red', 'yellow']) used to color collecitve events. Cycles through list.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object for the noodle plot.
            axes (matplotlib.axes.Axes): Matplotlib axes for the nooble plot.
        """
        if projection_axis not in [self.posx, self.posy, self.posz]:
            raise ValueError(f"projection_axis has to be one of {[self.posx, self.posy, self.posz]}")
        if projection_axis == self.posx:
            self.projection_index = 3
        elif projection_axis == self.posy:
            self.projection_index = 4
        elif projection_axis == self.posz:
            self.projection_index = 5
        if self.df.empty:
            grpd_data: list[np.ndarray] = []
            colors: np.ndarray = np.array([])
        else:
            grpd_data, colors = self._prepare_data_noodleplot(
                self.df,
                color_cylce,
                self.clid_column,
                self.obj_id_column,
                self.frame_column,
                self.posx,
                self.posy,
                self.posz,
            )
        fig, axes = self._create_noodle_plot(grpd_data, colors)
        return fig, axes


class LineagePlot:
    """Class to draw a lineage tree of clusters over time.

    Attributes:
        figsize (tuple): Size of the figure.
        node_size (int): Size of the nodes.
        edge_width (int): Width of the edges.
        edge_alpha (float): Alpha value of the edges.
        color_seed (int): Seed for the color generation.
        title (str): Title of the plot.
        xlabel (str): Label of the x-axis.
        ylabel (str): Label of the y-axis.
        font_size (int): Font size of the labels.
        curve_factor (float): Factor to curve the edges.
        orphan_color (tuple): Color of the orphan nodes.
        color_by (str): Attribute to color the plot by ('lineage_id' or 'cluster_id').
        show_node_labels (bool): If True, display node labels on the plot.
        main_lineage_id (int): The lineage ID of the main lineage to be plotted on the same row.
    """

    def __init__(
        self,
        figsize=(18, 18),
        node_size=50,
        edge_width=2,
        edge_alpha=0.8,
        color_seed=42,
        title="Cluster Lineage Tree",
        xlabel="Frame",
        ylabel="Lineage",
        font_size=16,
        curve_factor=0.9,
        orphan_color=(0.7, 0.7, 0.7, 1.0),
        color_by='lineage_id',  # 'lineage_id' or 'cluster_id'
        show_node_labels=False,  # Whether to display node labels
        main_lineage_id=None,  # The main lineage to keep on the same row
    ):
        """Constructs class with given parameters."""
        self.fig, self.ax = plt.subplots(figsize=figsize)
        self.node_size = node_size
        self.edge_width = edge_width
        self.edge_alpha = edge_alpha
        self.title = title
        self.xlabel = xlabel
        self.ylabel = ylabel
        self.font_size = font_size
        self.curve_factor = curve_factor
        self.orphan_color = orphan_color
        self.color_seed = color_seed
        self.color_by = color_by
        self.show_node_labels = show_node_labels
        self.main_lineage_id = main_lineage_id  # Store the main lineage ID

        self.colors: Dict[int, Tuple[float, float, float, float]] = {}
        self.node_positions: Dict[Tuple[int, int], Tuple[float, float]] = {}
        self.lineage_edges: List[Tuple[Tuple[int, int], Tuple[int, int]]] = []
        self.node_color: Dict[Tuple[int, int], Tuple[float, float, float, float]] = {}
        self.child_to_parent: Dict[Tuple[int, int], Set[Tuple[int, int]]] = {}
        self.parent_to_child: Dict[Tuple[int, int], Set[Tuple[int, int]]] = {}
        self.lineage_order: List[int] = []
        self.all_nodes: Set[Tuple[int, int]] = set()
        self.frame_to_nodes: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        self.node_to_lineage_id: Dict[Tuple[int, int], int] = {}
        self.node_to_cluster_id: Dict[Tuple[int, int], int] = {}
        self.node_to_plot_lineage_id: Dict[Tuple[int, int], int] = {}
        self.plot_lineage_id_to_lineage_id: Dict[int, int] = {}  # New mapping

    def _process_data(self, tracker):
        """Processes the lineage tracker data to prepare for plotting."""
        # Initialize data structures
        self.all_nodes = set()
        self.frame_to_nodes = defaultdict(list)
        self.parent_to_child = defaultdict(set)
        self.child_to_parent = defaultdict(set)
        self.lineage_edges = []
        self.minframe_nodes = set()
        self.node_to_lineage_id = {}
        self.node_to_cluster_id = {}

        # Expand nodes and edges based on parent-child relationships over time
        for node in tracker.nodes.values():
            lineage_id = node.lineage_id

            # Directly connect minframe to maxframe
            source = (node.minframe, node.cluster_id)
            target = (node.maxframe, node.cluster_id)
            self.lineage_edges.append((source, target))
            self.all_nodes.add(source)
            self.all_nodes.add(target)
            self.parent_to_child[source].add(target)
            self.child_to_parent[target].add(source)

            # Track node persistence
            self.all_nodes.add(source)
            self.all_nodes.add(target)
            self.frame_to_nodes[source[0]].append(source)
            self.frame_to_nodes[target[0]].append(target)
            self.node_to_lineage_id[source] = lineage_id
            self.node_to_cluster_id[source] = node.cluster_id
            self.node_to_lineage_id[target] = lineage_id
            self.node_to_cluster_id[target] = node.cluster_id

            # Add to minframe_nodes if it's the first frame
            self.minframe_nodes.add(source)

            # Add edges between parent and child clusters
            child_start_frame = node.minframe
            child_node = (child_start_frame, node.cluster_id)
            for parent in node.parents:
                parent_end_frame = parent.maxframe
                parent_node = (parent_end_frame, parent.cluster_id)
                self.lineage_edges.append((parent_node, child_node))
                self.parent_to_child[parent_node].add(child_node)
                self.child_to_parent[child_node].add(parent_node)

        # Generate plotting lineage IDs
        self._generate_plot_lineage_ids()

        # Assign colors based on the selected attribute
        self._assign_colors(tracker)
        # Order lineages including both merging and splitting events
        self._order_lineages_by_merging_and_splitting_events(tracker)

        # Position nodes based on plotting lineage order
        plot_lineage_id_to_y = {lineage_id: idx for idx, lineage_id in enumerate(self.lineage_order)}
        max_idx = len(plot_lineage_id_to_y) - 1 if len(plot_lineage_id_to_y) > 0 else 1
        self.node_positions = {}
        for node_tuple in self.all_nodes:
            frame, cluster_id = node_tuple
            x = frame
            plot_lineage_id = self.node_to_plot_lineage_id.get(node_tuple, None)
            if plot_lineage_id is not None:
                y = plot_lineage_id_to_y[plot_lineage_id] / max_idx if max_idx > 0 else 0.5
            else:
                y = 0.5  # Assign a default position for nodes without a lineage
            self.node_positions[node_tuple] = (x, y)

    def _generate_plot_lineage_ids(self):
        """Assigns plotting lineage IDs to all nodes, ensuring continuity."""
        self.node_to_plot_lineage_id = {}
        self.plot_lineage_id_to_lineage_id = {}
        plot_lineage_counter = 0

        # Get all unique lineage IDs, prioritizing the main lineage
        lineage_ids = set(self.node_to_lineage_id.values())
        if self.main_lineage_id is not None and self.main_lineage_id in lineage_ids:
            lineage_ids = [self.main_lineage_id] + [lid for lid in lineage_ids if lid != self.main_lineage_id]
        else:
            lineage_ids = list(lineage_ids)

        for lineage_id in lineage_ids:
            # Get all nodes for this lineage_id
            lineage_nodes = {node for node, lid in self.node_to_lineage_id.items() if lid == lineage_id}

            # Get root nodes (nodes without parents in this lineage)
            root_nodes = {
                node
                for node in lineage_nodes
                if not any(parent in lineage_nodes for parent in self.child_to_parent.get(node, []))
            }

            for root_node in root_nodes:
                stack = [(root_node, plot_lineage_counter)]
                self.plot_lineage_id_to_lineage_id[plot_lineage_counter] = lineage_id
                plot_lineage_counter += 1

                while stack:
                    current_node, current_plot_lineage_id = stack.pop()
                    if current_node in self.node_to_plot_lineage_id:
                        continue
                    self.node_to_plot_lineage_id[current_node] = current_plot_lineage_id

                    # Get children in the same lineage
                    children = [
                        child
                        for child in self.parent_to_child.get(current_node, [])
                        if self.node_to_lineage_id.get(child) == lineage_id
                    ]

                    if len(children) > 1:
                        # Node splits, assign new plot_lineage_ids to each branch
                        for child in children:
                            stack.append((child, plot_lineage_counter))
                            self.plot_lineage_id_to_lineage_id[plot_lineage_counter] = lineage_id
                            plot_lineage_counter += 1
                    else:
                        for child in children:
                            stack.append((child, current_plot_lineage_id))

        # For nodes not assigned plot_lineage_ids (could be orphans), assign new plot_lineage_ids
        for node in self.all_nodes:
            if node not in self.node_to_plot_lineage_id:
                lineage_id = self.node_to_lineage_id.get(node, None)
                if lineage_id is None:
                    continue
                self.node_to_plot_lineage_id[node] = plot_lineage_counter
                self.plot_lineage_id_to_lineage_id[plot_lineage_counter] = lineage_id
                plot_lineage_counter += 1

    def _assign_colors(self, tracker):
        """Assigns colors to nodes based on the selected attribute."""
        if self.color_by == 'lineage_id':
            # Assign colors based on true lineage IDs
            unique_ids = {node.lineage_id for node in tracker.nodes.values()}
            id_to_color_attr = self.node_to_lineage_id
        elif self.color_by == 'cluster_id':
            # Collect unique cluster IDs
            unique_ids = set(self.node_to_cluster_id.values())
            id_to_color_attr = self.node_to_cluster_id
        else:
            raise ValueError(f"Invalid color_by value: {self.color_by}. Use 'lineage_id' or 'cluster_id'.")

        # Generate colors
        colors = self._generate_colors(len(unique_ids))
        color_map = dict(zip(unique_ids, colors))

        # Assign colors to nodes
        for node_tuple in self.all_nodes:
            node_id = id_to_color_attr.get(node_tuple)
            if node_id is None:
                color = self.orphan_color
            else:
                color = color_map.get(node_id, self.orphan_color)
            self.node_color[node_tuple] = color

    def _order_lineages_by_merging_and_splitting_events(self, tracker):
        """Orders the lineages to minimize overlap and crossings using hierarchical clustering."""
        # Build a lineage graph that includes both merging and splitting events
        lineage_graph = defaultdict(set)  # plot_lineage_id -> set of connected plot_lineage_ids

        # Map from node tuples to nodes for easy access
        for node_tuple in self.all_nodes:
            plot_lineage_id = self.node_to_plot_lineage_id.get(node_tuple)
            if plot_lineage_id is None:
                continue

            # Merging and splitting events
            connected_nodes = self.parent_to_child.get(node_tuple, set()) | self.child_to_parent.get(node_tuple, set())
            for connected_node in connected_nodes:
                connected_plot_lineage_id = self.node_to_plot_lineage_id.get(connected_node)
                if connected_plot_lineage_id is not None and connected_plot_lineage_id != plot_lineage_id:
                    lineage_graph[plot_lineage_id].add(connected_plot_lineage_id)
                    lineage_graph[connected_plot_lineage_id].add(plot_lineage_id)

        # Attempt to group plotting lineages of the same true lineage
        # by adding edges between them in the lineage graph
        for plot_lineage_id_i in self.plot_lineage_id_to_lineage_id:
            lineage_id_i = self.plot_lineage_id_to_lineage_id[plot_lineage_id_i]
            for plot_lineage_id_j in self.plot_lineage_id_to_lineage_id:
                if plot_lineage_id_i >= plot_lineage_id_j:
                    continue
                lineage_id_j = self.plot_lineage_id_to_lineage_id[plot_lineage_id_j]
                if lineage_id_i == lineage_id_j:
                    # Add a strong connection between plotting lineages of the same true lineage
                    lineage_graph[plot_lineage_id_i].add(plot_lineage_id_j)
                    lineage_graph[plot_lineage_id_j].add(plot_lineage_id_i)

        # Collect all plotting lineage IDs
        lineage_ids = sorted(set(self.node_to_plot_lineage_id.values()))
        lineage_id_to_index = {lid: idx for idx, lid in enumerate(lineage_ids)}
        n_lineages = len(lineage_ids)

        # Initialize adjacency matrix
        adjacency_matrix = np.zeros((n_lineages, n_lineages))

        # Set adjacency between connected lineages
        for lineage_id, neighbors in lineage_graph.items():
            i = lineage_id_to_index[lineage_id]
            for neighbor in neighbors:
                j = lineage_id_to_index[neighbor]
                adjacency_matrix[i, j] = 1
                adjacency_matrix[j, i] = 1  # Ensure symmetry

        # Set diagonal elements to 1 (lineages are connected to themselves)
        np.fill_diagonal(adjacency_matrix, 1)

        # Compute distance matrix (convert adjacency to distances)
        # Lineages that are connected have distance 0, others have distance 1
        distance_matrix = 1 - adjacency_matrix

        # Ensure the distance matrix has zeros on the diagonal
        np.fill_diagonal(distance_matrix, 0)

        # Use hierarchical clustering with the distance matrix
        if n_lineages > 1:
            # Convert to condensed distance matrix for linkage
            condensed_distance = squareform(distance_matrix)
            Z = linkage(condensed_distance, method='median')
            dendro = dendrogram(Z, no_plot=True)
            order = dendro['leaves']
            lineage_order = [lineage_ids[i] for i in order]
        else:
            lineage_order = lineage_ids

        # Move plot_lineage_ids corresponding to main_lineage_id to the beginning
        if self.main_lineage_id is not None:
            main_lineage_plot_ids = [
                pid for pid, lid in self.plot_lineage_id_to_lineage_id.items() if lid == self.main_lineage_id
            ]
            lineage_order = [pid for pid in lineage_order if pid not in main_lineage_plot_ids]
            lineage_order = main_lineage_plot_ids + lineage_order

        # Second pass: Adjust the lineage_order to minimize vertical distances of merging events
        lineage_order = self._adjust_lineage_order(lineage_order, lineage_graph)

        self.lineage_order = lineage_order

    def _adjust_lineage_order(self, lineage_order, lineage_graph, max_iterations=10):
        """Iteratively adjusts the lineage order to minimize crossings."""
        # Initialize positions
        positions = {lineage_id: index for index, lineage_id in enumerate(lineage_order)}

        # If main_lineage_id is specified, get its plotting_lineage_ids and fix their positions
        fixed_positions = {}
        if self.main_lineage_id is not None:
            main_lineage_plot_ids = [
                pid for pid, lid in self.plot_lineage_id_to_lineage_id.items() if lid == self.main_lineage_id
            ]
            for idx, pid in enumerate(main_lineage_plot_ids):
                positions[pid] = idx  # Move them to the beginning
                fixed_positions[pid] = positions[pid]

        # Perform iterative position adjustments
        for _ in range(max_iterations):
            new_positions = positions.copy()

            for lineage_id in positions:
                if lineage_id in fixed_positions:
                    continue  # Skip fixed positions
                connected_lineages = lineage_graph[lineage_id]
                if not connected_lineages:
                    continue

                avg_position = sum(positions[neighbor] for neighbor in connected_lineages) / len(connected_lineages)
                new_positions[lineage_id] = (positions[lineage_id] + avg_position) / 2

            # After updating positions, sort the lineages
            sorted_lineages = sorted(new_positions.items(), key=lambda x: x[1])

            # Re-assign positions to be 0,1,2,...
            positions = {lineage_id: index for index, (lineage_id, _) in enumerate(sorted_lineages)}

            # Update fixed_positions
            for pid in fixed_positions:
                positions[pid] = fixed_positions[pid]

        # Return the final ordering
        lineage_order = [lineage_id for lineage_id, _ in sorted(positions.items(), key=lambda x: x[1])]
        return lineage_order

    def _generate_colors(self, n: int) -> List[Tuple[float, float, float, float]]:
        """Generates a list of distinct colors."""
        colors = []
        rng = np.random.default_rng(self.color_seed)
        for i in range(n):
            hue = rng.random()
            rgb = colorsys.hsv_to_rgb(hue, 0.8, 0.8)
            colors.append((*rgb, 1.0))
        return colors

    def _draw_curved_edge(self, start, end, color):
        """Draw a curved edge between two points, with the specified color."""
        mid_x = (start[0] + end[0]) / 2
        mid_y1 = start[1] + (end[1] - start[1]) * self.curve_factor
        mid_y2 = end[1] - (end[1] - start[1]) * self.curve_factor
        path = Path(
            [start, (mid_x, mid_y1), (mid_x, mid_y2), end], [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]
        )
        patch = patches.PathPatch(
            path, facecolor="none", edgecolor=color, alpha=self.edge_alpha, linewidth=self.edge_width
        )
        self.ax.add_patch(patch)

    def draw_tree(self, tracker):
        """Draw the lineage tree based on the processed data."""
        self._process_data(tracker)

        # Draw edges with assigned coloring
        for source, target in self.lineage_edges:
            source_pos = self.node_positions[source]
            target_pos = self.node_positions[target]
            color = self.node_color.get(source, self.orphan_color)
            self._draw_curved_edge(source_pos, target_pos, color)

        # Draw nodes
        for node in self.minframe_nodes:
            pos = self.node_positions[node]
            color = self.node_color.get(node, self.orphan_color)
            self.ax.scatter(pos[0], pos[1], s=self.node_size, c=[color], zorder=2)
            if self.show_node_labels:
                label = f"{node[1]}"  # Use cluster_id as label
                self.ax.text(pos[0], pos[1], label, fontsize=self.font_size - 4, ha='right', va='bottom')

        # Set labels and title
        self.ax.set_title(self.title, fontsize=self.font_size)
        self.ax.set_xlabel(self.xlabel, fontsize=self.font_size - 2)
        self.ax.set_ylabel(self.ylabel, fontsize=self.font_size - 2)

        # Set y-ticks to plotting lineage IDs with true lineage IDs as labels
        lineage_ids = self.lineage_order
        plot_lineage_id_to_y = {lineage_id: idx for idx, lineage_id in enumerate(lineage_ids)}
        max_idx = len(lineage_ids) - 1 if len(lineage_ids) > 0 else 1
        y_ticks = [plot_lineage_id_to_y[lineage_id] / max_idx if max_idx > 0 else 0.5 for lineage_id in lineage_ids]
        # Get corresponding true lineage IDs for labels
        y_tick_labels = [self.plot_lineage_id_to_lineage_id[lineage_id] for lineage_id in lineage_ids]
        self.ax.set_yticks(y_ticks)
        self.ax.set_yticklabels(y_tick_labels, fontsize=self.font_size - 4)
        plt.tight_layout()

    def show(self):
        """Display the plot."""
        plt.show()
