"""Module to plot different metrics generated by arcos4py functions.

Examples:
    >>> # Data Plots
    >>> from arcos4py.plotting import dataPlots
    >>> data_plots = dataPlots(df,'time', 'meas', 'track_id')
    >>> hist = data_plots.histogram()
    >>> dens = data_plots.density_plot()
    >>> xt_plot = data_plots.position_t_plot({'x'}, n=20)

    >>> # Detrended vs original plot
    >>> from arcos4py.plotting import plotOriginalDetrended
    >>> arcosPlots = plotOriginalDetrended(data, 'time', 'meas', 'detrended', 'id')
    >>> plot = arcosPlots(data, 'time', 'meas', 'detrended', 'id')
    >>> plot.plot_detrended()

    >>> # Stats Plot
    >>> from arcos4py.plotting import statsPlots
    >>> coll_dur_size_scatter = statsPlots(stats).plot_events_duration('total_size','duration')

    >>> # Noodle Plot
    >>> from arcos4py.plotting import NoodlePlot
    >>> ndl = NoodlePlot(df,"collid", 'track_id', 'time', 'x', 'y')
    >>> ndl_plot = ndl.plot('x')
"""

from __future__ import annotations

import colorsys
import logging
import math
import os
import warnings
from collections import defaultdict
from typing import Any, Dict, Generator, List, Optional, Set, Tuple, Union

import matplotlib.cm as cm
import matplotlib.patches as patches
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.axes import Axes
from matplotlib.collections import LineCollection
from matplotlib.colors import Colormap, Normalize
from matplotlib.figure import Figure
from matplotlib.path import Path
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.spatial import ConvexHull
from scipy.spatial.distance import squareform
from tqdm.auto import tqdm

from ..tools._arcos4py_deprecation import handle_deprecated_params

DEFAULT_EVENT_CMAP = 'tab20'
DEFAULT_BIN_COLOR = 'black'
DEFAULT_ALL_CELLS_CMAP = 'viridis'
DEFAULT_ALL_CELLS_FIXED_COLOR = 'gray'

logging.basicConfig(level=logging.INFO)

TAB20 = [
    "#1f77b4",
    "#aec7e8",
    "#ff7f0e",
    "#ffbb78",
    "#2ca02c",
    "#98df8a",
    "#d62728",
    "#ff9896",
    "#9467bd",
    "#c5b0d5",
    "#8c564b",
    "#c49c94",
    "#e377c2",
    "#f7b6d2",
    "#7f7f7f",
    "#c7c7c7",
    "#bcbd22",
    "#dbdb8d",
    "#17becf",
    "#9edae5",
]


class dataPlots:
    """Plot different metrics of input data.

    Attributes:
        data (Dataframe): containing ARCOS data.
        frame_column (str): name of frame column in data.
        measurement_column (str): name of measurement column in data.
        obj_id_column (str): name of track id column.
    """

    def __init__(
        self,
        data: pd.DataFrame,
        frame_column: str = 'frame',
        measurement_column: str = 'm',
        obj_id_column: str = 'obj_id',
        **kwargs,
    ):
        """Plot different metrics such as histogram, position-t and density.

        Arguments:
            data (Dataframe): containing ARCOS data.
            frame_column (str): name of frame column in data.
            measurement_column (str): name of measurement column in data.
            obj_id_column (str): name of track id column.
            **kwargs (Any): Additional keyword arguments. Includes deprecated parameters.
                - id (str): Deprecated. Use obj_id_column instead.
                - frame (str): Deprecated. Use frame_column instead.
                - measurement (str): Deprecated. Use measurement_column instead.
        """
        map_deprecated_params = {
            "id": "obj_id_column",
            "frame": "frame_column",
            "measurement": "measurement_column",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        obj_id_column = updated_kwargs.get("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.get("frame_column", frame_column)
        measurement_column = updated_kwargs.get("measurement_column", measurement_column)

        self.data = data
        self.obj_id = obj_id_column
        self.frame_column = frame_column
        self.measurement_column = measurement_column

    def position_t_plot(self, position_columns: set[str] = {'x'}, n: int = 20, **kwargs) -> Union[plt.Figure, Any]:
        """Plots X and Y over T to visualize tracklength.

        Arguments:
            position_columns (set): containing names of position columns in data.
            n (int): number of samples to plot.
            **kwargs (Any): Additional keyword arguments. Includes deprecated parameters.
                - posCol (set): Deprecated. Use position_columns instead.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of density plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of density plot.
        """
        map_deprecated_params = {
            "posCol": "position_columns",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        position_columns = updated_kwargs.get("position_columns", position_columns)

        sample = pd.Series(self.data[self.obj_id].unique()).sample(n)
        pd_from_r_df = self.data.loc[self.data[self.obj_id].isin(sample)]
        fig, axes = plt.subplots(1, len(position_columns), figsize=(6, 3))
        for _, df in pd_from_r_df.groupby(self.obj_id):
            for index, value in enumerate(position_columns):
                if len(position_columns) > 1:
                    df.plot(x=self.frame_column, y=value, ax=axes[index], legend=None)
                else:
                    df.plot(x=self.frame_column, y=value, ax=axes, legend=None)
        if len(position_columns) > 1:
            for index, value in enumerate(position_columns):
                axes[index].set_title(value)
        else:
            axes.set_title(value)
        return fig, axes

    def density_plot(self, *args, **kwargs):
        """Density plot of measurement.

        Uses Seaborn distplot to plot measurement density.

        Arguments:
            *args (Any): arguments passed on to seaborn histplot function.
            **kwargs (Any): keyword arguments passed on to seaborn histplot function.

        Returns:
            FacetGrid (seaborn.FacetGrid): Seaborn FacetGrid of density density plot.
        """
        plot = sns.displot(
            self.data[self.measurement_column],
            kind="kde",
            palette="pastel",
            label=self.measurement_column,
            *args,
            **kwargs,
        )
        # Plot formatting
        plt.legend(prop={'size': 10})
        plt.title('Density Plot of Measurement')
        plt.xlabel('Measurement')
        plt.ylabel('Density')
        return plot

    def histogram(self, bins: str = 'auto', *args, **kwargs) -> plt.Axes:
        """Histogram of tracklenght.

        Uses seaborn histplot function to plot tracklenght histogram.

        Arguments:
            bins (str): number or width of bins in histogram
            *args (Any): arguments passed on to seaborn histplot function.
            **kwargs (Any): keyword arguments passed on to seaborn histplot function.

        Returns:
            AxesSubplot: Matplotlib AxesSubplot of histogram.
        """
        # Draw histogram
        track_length = self.data.groupby(self.obj_id).size()
        axes = sns.histplot(track_length, label="Track Length", bins=bins, *args, **kwargs)
        # Plot formatting
        plt.title('Track length Histogram')
        axes.set_xlabel('Track Length')
        axes.set_ylabel('Count')
        return axes


class plotOriginalDetrended:
    """Plot original and detrended data.

    Attributes:
        data (DataFrame): containing ARCOS data.
        frame_column (str): name of frame column in data.
        measurement_column (str): name of measurement column in data.
        detrended_column (str): name of detrended column in data.
        obj_id_column (str): name of track id column.
        seed (int): seed for random number generator.

    Methods:
        plot_detrended: plot detrended data.
        plot_original: plot original data.
        plot_original_and_detrended: plot original and detrended data.
    """

    def __init__(
        self,
        data: pd.DataFrame,
        frame_column: str = "frame",
        measurement_column: str = "m",
        detrended_column: str = "m_detrended",
        obj_id_column: str = "obj_id",
        seed: int = 42,
        **kwargs,
    ):
        """Constructs class with given parameters."""
        map_deprecated_params = {
            "id": "obj_id_column",
            "frame": "frame_column",
            "detrended": "detrended_column",
            "measurement": "measurement_column",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        obj_id_column = updated_kwargs.get("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.get("frame_column", frame_column)
        measurement_column = updated_kwargs.get("measurement_column", measurement_column)

        self.data = data
        self.frame_column = frame_column
        self.measurement_column = measurement_column
        self.detrended_column = detrended_column
        self.obj_id_column = obj_id_column
        self.seed = seed

    def _prepare_data(self, n_samples: int):
        rng_gen = np.random.default_rng(seed=self.seed)
        vals = rng_gen.choice(self.data[self.obj_id_column].unique(), n_samples, replace=False)  # noqa: F841
        filtered_data = self.data.query(f"{self.obj_id_column} in @vals")
        return filtered_data.groupby(self.obj_id_column)

    def _plot_data(self, grouped, ncols, nrows, plotsize, plot_columns, labels, add_binary_segments=False):
        fig, axes2d = plt.subplots(nrows=nrows, ncols=ncols, figsize=plotsize, sharey=True)
        max_val = 0
        for (name, group), ax in zip(grouped, axes2d.flatten()):
            for column, label in zip(plot_columns, labels):
                ax.plot(group[self.frame_column], group[column], label=label)
                max_val = group[column].max() if group[column].max() > max_val else max_val
            ax.set_title(f"Track {name}")

        if add_binary_segments:
            for (name, group), ax in zip(grouped, axes2d.flatten()):
                self._add_binary_segments(group, ax, max_val)

        fig.supxlabel('Time Point')
        fig.supylabel('Measurement')
        handles, labels = ax.get_legend_handles_labels()
        fig.tight_layout()
        fig.legend(handles, labels, loc='upper right')

        return fig, axes2d

    def _add_binary_segments(self, group, ax, max_val):
        x_val = group[group[f"{self.measurement_column}.bin"] != 0][self.frame_column]
        y_val = np.repeat(max_val, x_val.size)
        indices = np.where(np.diff(x_val) != 1)[0] + 1
        x_split = np.split(x_val, indices)
        y_split = np.split(y_val, indices)
        for idx, (x_val, y_val) in enumerate(zip(x_split, y_split)):
            if idx == 0:
                ax.plot(x_val, y_val, color="red", lw=2, label="bin")
            else:
                ax.plot(x_val, y_val, color="red", lw=2)

    def plot_detrended(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots detrended data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped, subplots[0], subplots[1], plotsize, [self.detrended_column], ["detrended"], add_binary_segments
        )

    def plot_original(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots original data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped,
            subplots[0],
            subplots[1],
            plotsize,
            [self.measurement_column],
            ["original"],
            add_binary_segments,
        )

    def plot_original_and_detrended(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots original and detrended data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped,
            subplots[0],
            subplots[1],
            plotsize,
            [self.measurement_column, self.detrended_column],
            ["original", "detrended"],
            add_binary_segments,
        )


class statsPlots:
    """Plot data generated by the stats module.

    Attributes:
        data (DataFrame): containing ARCOS stats data.
    """

    def __init__(self, data: pd.DataFrame):
        """Plot detrended vs original data.

        Arguments:
            data (DataFrame): containing ARCOS stats data.
        """
        self.data = data

    def plot_events_duration(self, total_size: str, duration: str, point_size: int = 40, *args, **kwargs) -> plt.Axes:
        """Scatterplot of collective event duration.

        Arguments:
            total_size (str): name of total size column.
            duration (str):, name of column with collective event duration.
            point_size (int): scatterplot point size.
            *args (Any): Arguments passed on to seaborn scatterplot function.
            **kwargs (Any): Keyword arguments passed on to seaborn scatterplot function.

        Returns:
            Axes (matplotlib.axes.Axes): Matplotlib Axes object of scatterplot
        """
        plot = sns.scatterplot(x=self.data[total_size], y=self.data[duration], s=point_size, *args, **kwargs)
        return plot


class NoodlePlot:
    """Create Noodle Plot of cell tracks, colored by collective event id.

    Attributes:
        df (pd.DataFrame): DataFrame containing collective events from arcos.
        colev (str): Name of the collective event column in df.
        trackid (str): Name of the track column in df.
        frame (str): Name of the frame column in df.
        posx (str): Name of the X coordinate column in df.
        posy (str): Name of the Y coordinate column in df.
        posz (str): Name of the Z coordinate column in df,
            or None if no z column.
    """

    def __init__(
        self,
        df: pd.DataFrame,
        clid_column: str = "collid",
        obj_id_column: str = "obj_id",
        frame_column: str = "frame",
        posx: str = "x",
        posy: str = "y",
        posz: Union[str, None] = None,
        **kwargs,
    ):
        """Constructs class with given parameters.

        Arguments:
            df (pd.DataFrame): DataFrame containing collective events from arcos.
            clid_column (str): Name of the collective event column in df.
            obj_id_column (str): Name of the track column in df.
            frame_column (str): Name of the frame column in df.
            posx (str): Name of the X coordinate column in df.
            posy (str): Name of the Y coordinate column in df.
            posz (str | None): Name of the Z coordinate column in df,
                or None if no z column.
            **kwargs (Any): Additional keyword arguments for plot. Includes deprecated parameters.
                - colev (str): Deprecated. Use clid_column instead.
                - trackid (str): Deprecated. Use obj_id_column instead.
                - frame (str): Deprecated. Use frame_column instead.
        """
        map_deprecated_params = {
            "colev": "clid_column",
            "trackid": "obj_id_column",
            "frame": "frame_column",
        }

        # allowed matplotlib kwargs
        allowed_kwargs = [
            "alpha",
            "animated",
            "c",
            "label",
            "linewidth",
            "linestyle",
            "marker",
            "markersize",
            "markeredgecolor",
            "markerfacecolor",
            "markerfacecoloralt",
            "markeredgewidth",
            "path_effects",
            "picker",
            "pickradius",
            "solid_capstyle",
            "solid_joinstyle",
            "transform",
            "visible",
            "zorder",
        ]

        # check allowed kwargs
        allowed_kwargs_2 = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs and key not in allowed_kwargs_2:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        clid_column = updated_kwargs.pop("clid_column", clid_column)
        obj_id_column = updated_kwargs.pop("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.pop("frame_column", frame_column)

        self.df = df
        self.clid_column = clid_column
        self.obj_id_column = obj_id_column
        self.frame_column = frame_column
        self.posx = posx
        self.posy = posy
        self.posz = posz
        self.plot_kwargs = updated_kwargs

    def _prepare_data_noodleplot(
        self,
        df: pd.DataFrame,
        color_cylce: list[str],
        clid_column: str,
        obj_id_column: str,
        frame_column: str,
        posx: str,
        posy: str,
        posz: Union[str, None] = None,
    ) -> tuple[list[np.ndarray], np.ndarray]:
        """From arcos collective event data,\
        generates a list of numpy arrays, one for each event.

        Arguments:
            df (pd.DataFrame): DataFrame containing collective events from arcos.
            color_cylce (list[str]): list of colors used to color trackid's
                for individual collective events.
            colev (str): Name of the collective event column in df.
            trackid (str): Name of the track column in df.
            frame: (str): Name of the frame column in df.
            posx (str): Name of the X coordinate column in df.
            posy (str): Name of the Y coordinate column in df.
            posz (str): Name of the Z coordinate column in df,
                or None if no z column.

        Returns:
            grouped_array (list[np.ndarray]): List of collective events data
            colors (np.ndarray): colors for each collective event.
        """
        df = df.copy()
        # factorize trackid to get unique values and make sure they are nummeric
        df[obj_id_column] = df[obj_id_column].factorize()[0]
        # sort by collective event and trackid
        df = df.sort_values([clid_column, obj_id_column])
        if posz:
            array = df[[clid_column, obj_id_column, frame_column, posx, posy, posz]].to_numpy()
        else:
            array = df[[clid_column, obj_id_column, frame_column, posx, posy]].to_numpy()
        # generate goroups for each unique value
        grouped_array = np.split(array, np.unique(array[:, 0], axis=0, return_index=True)[1][1:])
        # make collids sequential
        seq_colids = np.concatenate(
            [np.repeat(i, value.shape[0]) for i, value in enumerate(grouped_array)],
            axis=0,
        )
        array_seq_colids = np.column_stack((array, seq_colids))
        # split sequential collids array by trackid and collid
        grouped_array = np.split(
            array_seq_colids,
            np.unique(array_seq_colids[:, :2], axis=0, return_index=True)[1][1:],
        )
        # generate colors for each collective event, wrap arround the color cycle
        colors = np.take(np.array(color_cylce), [i + 1 for i in np.unique(seq_colids)], mode="wrap")
        return grouped_array, colors

    def _create_noodle_plot(self, grouped_data: list[np.ndarray], colors: np.ndarray):
        """Plots the noodle plot."""
        fig, ax = plt.subplots()
        ax.set_xlabel("Time Point")
        ax.set_ylabel("Position")
        for dat in grouped_data:
            if dat.size == 0:
                continue
            ax.plot(
                dat[:, 2],
                dat[:, self.projection_index],
                c=colors[int(dat[0, -1])],
                **self.plot_kwargs,
            )
        return fig, ax

    def plot(self, projection_axis: str, color_cylce: list[str] = TAB20):
        """Create Noodle Plot of cell tracks, colored by collective event id.

        Arguments:
            projection_axis (str): Specify with witch coordinate the noodle
                plot should be drawn. Has to be one of the posx, posy or posz arguments
                passed in during the class instantiation process.
            color_cylce (list[str]): List of hex color values or string names
                (i.e. ['red', 'yellow']) used to color collecitve events. Cycles through list.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object for the noodle plot.
            axes (matplotlib.axes.Axes): Matplotlib axes for the nooble plot.
        """
        if projection_axis not in [self.posx, self.posy, self.posz]:
            raise ValueError(f"projection_axis has to be one of {[self.posx, self.posy, self.posz]}")
        if projection_axis == self.posx:
            self.projection_index = 3
        elif projection_axis == self.posy:
            self.projection_index = 4
        elif projection_axis == self.posz:
            self.projection_index = 5
        if self.df.empty:
            grpd_data: list[np.ndarray] = []
            colors: np.ndarray = np.array([])
        else:
            grpd_data, colors = self._prepare_data_noodleplot(
                self.df,
                color_cylce,
                self.clid_column,
                self.obj_id_column,
                self.frame_column,
                self.posx,
                self.posy,
                self.posz,
            )
        fig, axes = self._create_noodle_plot(grpd_data, colors)
        return fig, axes


class LineagePlot:
    """Class to draw a lineage tree of clusters over time.

    Attributes:
        figsize (tuple): Size of the figure.
        node_size (int): Size of the nodes.
        edge_width (int): Width of the edges.
        edge_alpha (float): Alpha value of the edges.
        color_seed (int): Seed for the color generation.
        title (str): Title of the plot.
        xlabel (str): Label of the x-axis.
        ylabel (str): Label of the y-axis.
        font_size (int): Font size of the labels.
        curve_factor (float): Factor to curve the edges.
        orphan_color (tuple): Color of the orphan nodes.
        color_by (str): Attribute to color the plot by ('lineage_id' or 'cluster_id').
        show_node_labels (bool): If True, display node labels on the plot.
        main_lineage_id (int): The lineage ID of the main lineage to be plotted on the same row.
    """

    def __init__(
        self,
        figsize=(18, 18),
        node_size=50,
        edge_width=2,
        edge_alpha=0.8,
        color_seed=42,
        title="Cluster Lineage Tree",
        xlabel="Frame",
        ylabel="Lineage",
        font_size=16,
        curve_factor=0.9,
        orphan_color=(0.7, 0.7, 0.7, 1.0),
        color_by='lineage_id',  # 'lineage_id' or 'cluster_id'
        show_node_labels=False,  # Whether to display node labels
        main_lineage_id=None,  # The main lineage to keep on the same row
    ):
        """Constructs class with given parameters."""
        self.fig, self.ax = plt.subplots(figsize=figsize)
        self.node_size = node_size
        self.edge_width = edge_width
        self.edge_alpha = edge_alpha
        self.title = title
        self.xlabel = xlabel
        self.ylabel = ylabel
        self.font_size = font_size
        self.curve_factor = curve_factor
        self.orphan_color = orphan_color
        self.color_seed = color_seed
        self.color_by = color_by
        self.show_node_labels = show_node_labels
        self.main_lineage_id = main_lineage_id  # Store the main lineage ID

        self.colors: Dict[int, Tuple[float, float, float, float]] = {}
        self.node_positions: Dict[Tuple[int, int], Tuple[float, float]] = {}
        self.lineage_edges: List[Tuple[Tuple[int, int], Tuple[int, int]]] = []
        self.node_color: Dict[Tuple[int, int], Tuple[float, float, float, float]] = {}
        self.child_to_parent: Dict[Tuple[int, int], Set[Tuple[int, int]]] = {}
        self.parent_to_child: Dict[Tuple[int, int], Set[Tuple[int, int]]] = {}
        self.lineage_order: List[int] = []
        self.all_nodes: Set[Tuple[int, int]] = set()
        self.frame_to_nodes: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        self.node_to_lineage_id: Dict[Tuple[int, int], int] = {}
        self.node_to_cluster_id: Dict[Tuple[int, int], int] = {}
        self.node_to_plot_lineage_id: Dict[Tuple[int, int], int] = {}
        self.plot_lineage_id_to_lineage_id: Dict[int, int] = {}  # New mapping

    def _process_data(self, tracker):
        """Processes the lineage tracker data to prepare for plotting."""
        # Initialize data structures
        self.all_nodes = set()
        self.frame_to_nodes = defaultdict(list)
        self.parent_to_child = defaultdict(set)
        self.child_to_parent = defaultdict(set)
        self.lineage_edges = []
        self.minframe_nodes = set()
        self.node_to_lineage_id = {}
        self.node_to_cluster_id = {}

        # Expand nodes and edges based on parent-child relationships over time
        for node in tracker.nodes.values():
            lineage_id = node.lineage_id

            # Directly connect minframe to maxframe
            source = (node.minframe, node.cluster_id)
            target = (node.maxframe, node.cluster_id)
            self.lineage_edges.append((source, target))
            self.all_nodes.add(source)
            self.all_nodes.add(target)
            self.parent_to_child[source].add(target)
            self.child_to_parent[target].add(source)

            # Track node persistence
            self.all_nodes.add(source)
            self.all_nodes.add(target)
            self.frame_to_nodes[source[0]].append(source)
            self.frame_to_nodes[target[0]].append(target)
            self.node_to_lineage_id[source] = lineage_id
            self.node_to_cluster_id[source] = node.cluster_id
            self.node_to_lineage_id[target] = lineage_id
            self.node_to_cluster_id[target] = node.cluster_id

            # Add to minframe_nodes if it's the first frame
            self.minframe_nodes.add(source)

            # Add edges between parent and child clusters
            child_start_frame = node.minframe
            child_node = (child_start_frame, node.cluster_id)
            for parent in node.parents:
                parent_end_frame = parent.maxframe
                parent_node = (parent_end_frame, parent.cluster_id)
                self.lineage_edges.append((parent_node, child_node))
                self.parent_to_child[parent_node].add(child_node)
                self.child_to_parent[child_node].add(parent_node)

        # Generate plotting lineage IDs
        self._generate_plot_lineage_ids()

        # Assign colors based on the selected attribute
        self._assign_colors(tracker)
        # Order lineages including both merging and splitting events
        self._order_lineages_by_merging_and_splitting_events(tracker)

        # Position nodes based on plotting lineage order
        plot_lineage_id_to_y = {lineage_id: idx for idx, lineage_id in enumerate(self.lineage_order)}
        max_idx = len(plot_lineage_id_to_y) - 1 if len(plot_lineage_id_to_y) > 0 else 1
        self.node_positions = {}
        for node_tuple in self.all_nodes:
            frame, cluster_id = node_tuple
            x = frame
            plot_lineage_id = self.node_to_plot_lineage_id.get(node_tuple, None)
            if plot_lineage_id is not None:
                y = plot_lineage_id_to_y[plot_lineage_id] / max_idx if max_idx > 0 else 0.5
            else:
                y = 0.5  # Assign a default position for nodes without a lineage
            self.node_positions[node_tuple] = (x, y)

    def _generate_plot_lineage_ids(self):
        """Assigns plotting lineage IDs to all nodes, ensuring continuity."""
        self.node_to_plot_lineage_id = {}
        self.plot_lineage_id_to_lineage_id = {}
        plot_lineage_counter = 0

        # Get all unique lineage IDs, prioritizing the main lineage
        lineage_ids = set(self.node_to_lineage_id.values())
        if self.main_lineage_id is not None and self.main_lineage_id in lineage_ids:
            lineage_ids = [self.main_lineage_id] + [lid for lid in lineage_ids if lid != self.main_lineage_id]
        else:
            lineage_ids = list(lineage_ids)

        for lineage_id in lineage_ids:
            # Get all nodes for this lineage_id
            lineage_nodes = {node for node, lid in self.node_to_lineage_id.items() if lid == lineage_id}

            # Get root nodes (nodes without parents in this lineage)
            root_nodes = {
                node
                for node in lineage_nodes
                if not any(parent in lineage_nodes for parent in self.child_to_parent.get(node, []))
            }

            for root_node in root_nodes:
                stack = [(root_node, plot_lineage_counter)]
                self.plot_lineage_id_to_lineage_id[plot_lineage_counter] = lineage_id
                plot_lineage_counter += 1

                while stack:
                    current_node, current_plot_lineage_id = stack.pop()
                    if current_node in self.node_to_plot_lineage_id:
                        continue
                    self.node_to_plot_lineage_id[current_node] = current_plot_lineage_id

                    # Get children in the same lineage
                    children = [
                        child
                        for child in self.parent_to_child.get(current_node, [])
                        if self.node_to_lineage_id.get(child) == lineage_id
                    ]

                    if len(children) > 1:
                        # Node splits, assign new plot_lineage_ids to each branch
                        for child in children:
                            stack.append((child, plot_lineage_counter))
                            self.plot_lineage_id_to_lineage_id[plot_lineage_counter] = lineage_id
                            plot_lineage_counter += 1
                    else:
                        for child in children:
                            stack.append((child, current_plot_lineage_id))

        # For nodes not assigned plot_lineage_ids (could be orphans), assign new plot_lineage_ids
        for node in self.all_nodes:
            if node not in self.node_to_plot_lineage_id:
                lineage_id = self.node_to_lineage_id.get(node, None)
                if lineage_id is None:
                    continue
                self.node_to_plot_lineage_id[node] = plot_lineage_counter
                self.plot_lineage_id_to_lineage_id[plot_lineage_counter] = lineage_id
                plot_lineage_counter += 1

    def _assign_colors(self, tracker):
        """Assigns colors to nodes based on the selected attribute."""
        if self.color_by == 'lineage_id':
            # Assign colors based on true lineage IDs
            unique_ids = {node.lineage_id for node in tracker.nodes.values()}
            id_to_color_attr = self.node_to_lineage_id
        elif self.color_by == 'cluster_id':
            # Collect unique cluster IDs
            unique_ids = set(self.node_to_cluster_id.values())
            id_to_color_attr = self.node_to_cluster_id
        else:
            raise ValueError(f"Invalid color_by value: {self.color_by}. Use 'lineage_id' or 'cluster_id'.")

        # Generate colors
        colors = self._generate_colors(len(unique_ids))
        color_map = dict(zip(unique_ids, colors))

        # Assign colors to nodes
        for node_tuple in self.all_nodes:
            node_id = id_to_color_attr.get(node_tuple)
            if node_id is None:
                color = self.orphan_color
            else:
                color = color_map.get(node_id, self.orphan_color)
            self.node_color[node_tuple] = color

    def _order_lineages_by_merging_and_splitting_events(self, tracker):
        """Orders the lineages to minimize overlap and crossings using hierarchical clustering."""
        # Build a lineage graph that includes both merging and splitting events
        lineage_graph = defaultdict(set)  # plot_lineage_id -> set of connected plot_lineage_ids

        # Map from node tuples to nodes for easy access
        for node_tuple in self.all_nodes:
            plot_lineage_id = self.node_to_plot_lineage_id.get(node_tuple)
            if plot_lineage_id is None:
                continue

            # Merging and splitting events
            connected_nodes = self.parent_to_child.get(node_tuple, set()) | self.child_to_parent.get(node_tuple, set())
            for connected_node in connected_nodes:
                connected_plot_lineage_id = self.node_to_plot_lineage_id.get(connected_node)
                if connected_plot_lineage_id is not None and connected_plot_lineage_id != plot_lineage_id:
                    lineage_graph[plot_lineage_id].add(connected_plot_lineage_id)
                    lineage_graph[connected_plot_lineage_id].add(plot_lineage_id)

        # Attempt to group plotting lineages of the same true lineage
        # by adding edges between them in the lineage graph
        for plot_lineage_id_i in self.plot_lineage_id_to_lineage_id:
            lineage_id_i = self.plot_lineage_id_to_lineage_id[plot_lineage_id_i]
            for plot_lineage_id_j in self.plot_lineage_id_to_lineage_id:
                if plot_lineage_id_i >= plot_lineage_id_j:
                    continue
                lineage_id_j = self.plot_lineage_id_to_lineage_id[plot_lineage_id_j]
                if lineage_id_i == lineage_id_j:
                    # Add a strong connection between plotting lineages of the same true lineage
                    lineage_graph[plot_lineage_id_i].add(plot_lineage_id_j)
                    lineage_graph[plot_lineage_id_j].add(plot_lineage_id_i)

        # Collect all plotting lineage IDs
        lineage_ids = sorted(set(self.node_to_plot_lineage_id.values()))
        lineage_id_to_index = {lid: idx for idx, lid in enumerate(lineage_ids)}
        n_lineages = len(lineage_ids)

        # Initialize adjacency matrix
        adjacency_matrix = np.zeros((n_lineages, n_lineages))

        # Set adjacency between connected lineages
        for lineage_id, neighbors in lineage_graph.items():
            i = lineage_id_to_index[lineage_id]
            for neighbor in neighbors:
                j = lineage_id_to_index[neighbor]
                adjacency_matrix[i, j] = 1
                adjacency_matrix[j, i] = 1  # Ensure symmetry

        # Set diagonal elements to 1 (lineages are connected to themselves)
        np.fill_diagonal(adjacency_matrix, 1)

        # Compute distance matrix (convert adjacency to distances)
        # Lineages that are connected have distance 0, others have distance 1
        distance_matrix = 1 - adjacency_matrix

        # Ensure the distance matrix has zeros on the diagonal
        np.fill_diagonal(distance_matrix, 0)

        # Use hierarchical clustering with the distance matrix
        if n_lineages > 1:
            # Convert to condensed distance matrix for linkage
            condensed_distance = squareform(distance_matrix)
            Z = linkage(condensed_distance, method='median')
            dendro = dendrogram(Z, no_plot=True)
            order = dendro['leaves']
            lineage_order = [lineage_ids[i] for i in order]
        else:
            lineage_order = lineage_ids

        # Move plot_lineage_ids corresponding to main_lineage_id to the beginning
        if self.main_lineage_id is not None:
            main_lineage_plot_ids = [
                pid for pid, lid in self.plot_lineage_id_to_lineage_id.items() if lid == self.main_lineage_id
            ]
            lineage_order = [pid for pid in lineage_order if pid not in main_lineage_plot_ids]
            lineage_order = main_lineage_plot_ids + lineage_order

        # Second pass: Adjust the lineage_order to minimize vertical distances of merging events
        lineage_order = self._adjust_lineage_order(lineage_order, lineage_graph)

        self.lineage_order = lineage_order

    def _adjust_lineage_order(self, lineage_order, lineage_graph, max_iterations=10):
        """Iteratively adjusts the lineage order to minimize crossings."""
        # Initialize positions
        positions = {lineage_id: index for index, lineage_id in enumerate(lineage_order)}

        # If main_lineage_id is specified, get its plotting_lineage_ids and fix their positions
        fixed_positions = {}
        if self.main_lineage_id is not None:
            main_lineage_plot_ids = [
                pid for pid, lid in self.plot_lineage_id_to_lineage_id.items() if lid == self.main_lineage_id
            ]
            for idx, pid in enumerate(main_lineage_plot_ids):
                positions[pid] = idx  # Move them to the beginning
                fixed_positions[pid] = positions[pid]

        # Perform iterative position adjustments
        for _ in range(max_iterations):
            new_positions = positions.copy()

            for lineage_id in positions:
                if lineage_id in fixed_positions:
                    continue  # Skip fixed positions
                connected_lineages = lineage_graph[lineage_id]
                if not connected_lineages:
                    continue

                avg_position = sum(positions[neighbor] for neighbor in connected_lineages) / len(connected_lineages)
                new_positions[lineage_id] = (positions[lineage_id] + avg_position) / 2

            # After updating positions, sort the lineages
            sorted_lineages = sorted(new_positions.items(), key=lambda x: x[1])

            # Re-assign positions to be 0,1,2,...
            positions = {lineage_id: index for index, (lineage_id, _) in enumerate(sorted_lineages)}

            # Update fixed_positions
            for pid in fixed_positions:
                positions[pid] = fixed_positions[pid]

        # Return the final ordering
        lineage_order = [lineage_id for lineage_id, _ in sorted(positions.items(), key=lambda x: x[1])]
        return lineage_order

    def _generate_colors(self, n: int) -> List[Tuple[float, float, float, float]]:
        """Generates a list of distinct colors."""
        colors = []
        rng = np.random.default_rng(self.color_seed)
        for i in range(n):
            hue = rng.random()
            rgb = colorsys.hsv_to_rgb(hue, 0.8, 0.8)
            colors.append((*rgb, 1.0))
        return colors

    def _draw_curved_edge(self, start, end, color):
        """Draw a curved edge between two points, with the specified color."""
        mid_x = (start[0] + end[0]) / 2
        mid_y1 = start[1] + (end[1] - start[1]) * self.curve_factor
        mid_y2 = end[1] - (end[1] - start[1]) * self.curve_factor
        path = Path(
            [start, (mid_x, mid_y1), (mid_x, mid_y2), end], [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]
        )
        patch = patches.PathPatch(
            path, facecolor="none", edgecolor=color, alpha=self.edge_alpha, linewidth=self.edge_width
        )
        self.ax.add_patch(patch)

    def draw_tree(self, tracker):
        """Draw the lineage tree based on the processed data."""
        self._process_data(tracker)

        # Draw edges with assigned coloring
        for source, target in self.lineage_edges:
            source_pos = self.node_positions[source]
            target_pos = self.node_positions[target]
            color = self.node_color.get(source, self.orphan_color)
            self._draw_curved_edge(source_pos, target_pos, color)

        # Draw nodes
        for node in self.minframe_nodes:
            pos = self.node_positions[node]
            color = self.node_color.get(node, self.orphan_color)
            self.ax.scatter(pos[0], pos[1], s=self.node_size, c=[color], zorder=2)
            if self.show_node_labels:
                label = f"{node[1]}"  # Use cluster_id as label
                self.ax.text(pos[0], pos[1], label, fontsize=self.font_size - 4, ha='right', va='bottom')

        # Set labels and title
        self.ax.set_title(self.title, fontsize=self.font_size)
        self.ax.set_xlabel(self.xlabel, fontsize=self.font_size - 2)
        self.ax.set_ylabel(self.ylabel, fontsize=self.font_size - 2)

        # Set y-ticks to plotting lineage IDs with true lineage IDs as labels
        lineage_ids = self.lineage_order
        plot_lineage_id_to_y = {lineage_id: idx for idx, lineage_id in enumerate(lineage_ids)}
        max_idx = len(lineage_ids) - 1 if len(lineage_ids) > 0 else 1
        y_ticks = [plot_lineage_id_to_y[lineage_id] / max_idx if max_idx > 0 else 0.5 for lineage_id in lineage_ids]
        # Get corresponding true lineage IDs for labels
        y_tick_labels = [self.plot_lineage_id_to_lineage_id[lineage_id] for lineage_id in lineage_ids]
        self.ax.set_yticks(y_ticks)
        self.ax.set_yticklabels(y_tick_labels, fontsize=self.font_size - 4)
        plt.tight_layout()

    def show(self):
        """Display the plot."""
        plt.show()


def _yield_animation_frames(  # noqa: C901
    arcos_data: pd.DataFrame,
    all_cells_data: pd.DataFrame,
    frame_col: str,
    collid_col: str,
    pos_cols: List[str],
    measurement_col: Optional[str] = None,  # REQUIRED if coloring all_cells by measurement
    bin_col: Optional[str] = None,  # Optional: only needed if plotting specific binarized cells
    plot_all_cells: bool = True,
    color_all_cells_by_measurement: bool = True,
    plot_bin_cells: bool = True,
    plot_events: bool = True,
    plot_convex_hulls: bool = True,
    point_size: float = 10.0,
    event_cmap: str = DEFAULT_EVENT_CMAP,
    event_alpha: float = 0.9,
    hull_alpha: float = 0.8,
    hull_linewidth_size_factor: float = 1.0,
    bin_cell_color: str = DEFAULT_BIN_COLOR,
    bin_cell_alpha: float = 0.7,
    bin_cell_marker_factor: float = 0.8,
    all_cells_cmap: str = DEFAULT_ALL_CELLS_CMAP,
    all_cells_fixed_color: str = DEFAULT_ALL_CELLS_FIXED_COLOR,
    all_cells_alpha: float = 0.5,
    all_cells_marker_size_factor: float = 0.2,
    measurement_min_max: Optional[Tuple[Optional[float], Optional[float]]] = None,  # Allow None within Tuple
    add_measurement_colorbar: bool = True,
) -> Generator[Figure, None, None]:
    """Generates Matplotlib Figure objects for individual frames of a cell activity visualization.

    This function acts as a caller for the `yield_animation_frames` generator.
    It handles the iteration over frames, saving each frame to a file with
    appropriate naming and padding, and ensures figures are closed to free memory.

    Parameters
    ----------
    arcos_data : pd.DataFrame
        DataFrame containing cell activity data, potentially including collective
    event IDs (`collid_col`) and binarization status (`bin_col`).
    all_cells_data : pd.DataFrame
        DataFrame containing all cells (or a representative background set)
        for background plotting. Must include `frame_col`, `pos_cols`, and
        `measurement_col` if `color_all_cells_by_measurement` is True.
    output_dir : str
        Directory where the output frames will be saved.
    frame_col : str
        Name of the column indicating the time frame.
    collid_col : str
        Name of the column indicating the collective event ID.
        Values > 0 are treated as events.
    pos_cols : List[str]
        List of column names for spatial coordinates (e.g., ['x', 'y'] or ['x', 'y', 'z']).
    measurement_col : Optional[str], optional
        Name of the column containing the measurement value. REQUIRED if
        `color_all_cells_by_measurement` is True. Used for coloring background cells.
        Default None.
    bin_col : Optional[str], optional
        Name of the column indicating binarized activity (e.g., values > 0 mean
        binarized). Used for `plot_bin_cells`. Default None.
    plot_all_cells : bool, optional
        Whether to plot the background cells from `all_cells_data`. Default True.
    color_all_cells_by_measurement : bool, optional
        If True and `plot_all_cells` is True, color background cells using
        `measurement_col` and `all_cells_cmap`. Requires `measurement_col` to
        be valid in `all_cells_data`. If False or requirements not met, uses
        `all_cells_fixed_color`. Default True.
    plot_bin_cells : bool, optional
        Whether to plot cells marked active by `bin_col` but not part of a
        collective event (`collid_col` <= 0). Requires `bin_col` to be set.
        Default True.
    plot_events : bool, optional
        Whether to plot cells identified as part of collective events
        (`collid_col` > 0). Default True.
    plot_convex_hulls : bool, optional
        Whether to draw convex hulls around collective events (2D only).
        Default True.
    point_size : float, optional
        Base size for plotted points (event cells). Default 10.0.
    event_cmap : str, optional
        Name of the Matplotlib colormap used to assign unique colors to
        different collective event IDs. Default 'tab20'.
    event_alpha : float, optional
        Alpha transparency for event cells. Default 0.9.
    hull_alpha : float, optional
        Alpha transparency for convex hull lines. Default 0.8.
    hull_linewidth_size_factor : float, optional
        Size factor for convex hull line width. Default 1.0.
    bin_cell_color : str, optional
        Color for binarized (non-event) cells. Default 'black'.
    bin_cell_alpha : float, optional
        Alpha transparency for binarized (non-event) cells. Default 0.7.
    bin_cell_marker_factor : float, optional
        Size multiplier for binarized (non-event) cells relative to `point_size`.
        Default 0.8.
    all_cells_cmap : str, optional
        Name of the Matplotlib colormap used for background cells when
        `color_all_cells_by_measurement` is True. Default 'viridis'.
    all_cells_fixed_color : str, optional
        Color for background cells if `color_all_cells_by_measurement` is False
        or requirements are not met. Default 'gray'.
    all_cells_alpha : float, optional
        Alpha transparency for background cells. Default 0.5.
    all_cells_marker_size_factor : float, optional
        Size multiplier for background cells relative to `point_size`. Default 0.2.
    measurement_min_max : Optional[Tuple[float, float]], optional
        Manual min/max values for the measurement colormap normalization. If None,
        the range is determined from `all_cells_data[measurement_col]`. Default None.
    add_measurement_colorbar : bool, optional
        If True and coloring all cells by measurement, add a static colorbar
        to the figure. Default True.
    filename_prefix : str, optional
        Prefix for the output filenames. Default 'frame'.
    dpi : int, optional
        DPI for the saved images. Default 150.
    """
    # --- Input Validation and Setup ---
    if arcos_data.empty and (not plot_all_cells or all_cells_data.empty):
        warnings.warn(
            "No data to plot (ARCOS empty, and not plotting all cells or all_cells empty). Generator will yield no frames."
        )
        return

    _plot_bin_cells = plot_bin_cells
    if _plot_bin_cells and (bin_col is None or bin_col not in arcos_data.columns):
        warnings.warn(
            f"'plot_bin_cells' is True, but 'bin_col' ('{bin_col}') is not specified or not found in arcos_data.\
                Disabling plot_bin_cells."
        )
        _plot_bin_cells = False

    _plot_events = plot_events
    if _plot_events and (collid_col is None or collid_col not in arcos_data.columns):
        warnings.warn(
            f"'plot_events' is True, but 'collid_col' ('{collid_col}') is not found in arcos_data. Disabling plot_events."
        )
        _plot_events = False

    _plot_convex_hulls = plot_convex_hulls
    if _plot_convex_hulls and not _plot_events:
        warnings.warn(
            "'plot_convex_hulls' is True, but 'plot_events' is False. Hulls require events. Disabling hull plotting."
        )
        _plot_convex_hulls = False

    if not isinstance(pos_cols, list) or not (2 <= len(pos_cols) <= 3):
        raise ValueError(f"`pos_cols` must be a list of 2 or 3 column names, got {pos_cols}")

    can_color_all_by_meas = False
    if plot_all_cells and color_all_cells_by_measurement:
        if all_cells_data.empty:
            warnings.warn(
                "'color_all_cells_by_measurement' is True, but 'all_cells_data' is empty. Cannot color by measurement.\
                    Falling back to fixed color."
            )
        elif measurement_col is None:
            warnings.warn(
                "'color_all_cells_by_measurement' is True, but 'measurement_col' is not specified. Cannot color by measurement.\
                    Falling back to fixed color."
            )
        elif measurement_col not in all_cells_data.columns:
            warnings.warn(
                f"'color_all_cells_by_measurement' is True, but 'measurement_col' ('{measurement_col}') not found in\
                    'all_cells_data'. Falling back to fixed color."
            )
        elif all_cells_data[measurement_col].isnull().all():
            warnings.warn(
                f"'color_all_cells_by_measurement' is True, but 'measurement_col' ('{measurement_col}') contains only NaN values\
                    in 'all_cells_data'. Falling back to fixed color."
            )
        else:
            can_color_all_by_meas = True

    # --- Data Preparation ---
    is_3d = len(pos_cols) == 3

    arcos_data_copy = arcos_data.copy() if not arcos_data.empty else pd.DataFrame()
    all_cells_data_copy = all_cells_data.copy() if not all_cells_data.empty else pd.DataFrame()

    min_frame = float("inf")
    max_frame = float("-inf")

    if not arcos_data_copy.empty and frame_col in arcos_data_copy:
        min_frame = min(min_frame, arcos_data_copy[frame_col].min())
        max_frame = max(max_frame, arcos_data_copy[frame_col].max())

    if plot_all_cells and not all_cells_data_copy.empty and frame_col in all_cells_data_copy:
        min_frame = min(min_frame, all_cells_data_copy[frame_col].min())
        max_frame = max(max_frame, all_cells_data_copy[frame_col].max())

    if min_frame == float("inf") or max_frame == float("-inf"):
        warnings.warn(
            f"Could not determine frame range (no data with frame column '{frame_col}'?). Generator will yield no frames."
        )
        return

    min_frame = int(min_frame)
    max_frame = int(max_frame)
    frames = range(min_frame, max_frame + 1)

    arcos_data_grouped = arcos_data_copy.groupby(frame_col) if not arcos_data_copy.empty else None
    all_cells_grouped = (
        all_cells_data_copy.groupby(frame_col) if plot_all_cells and not all_cells_data_copy.empty else None
    )

    # --- Plotting Setup ---
    fig: Figure = plt.figure(figsize=(9, 8) if add_measurement_colorbar and can_color_all_by_meas else (8, 8))
    ax: Axes  # Type hint for ax
    try:
        ax = fig.add_subplot(111, projection="3d" if is_3d else None)

        all_pos_data = []
        if not arcos_data_copy.empty:
            all_pos_data.append(arcos_data_copy[pos_cols])
        if plot_all_cells and not all_cells_data_copy.empty:
            all_pos_data.append(all_cells_data_copy[pos_cols])

        if not all_pos_data:
            warnings.warn(
                f"No position data available ({pos_cols}) to determine axis limits. Generator will yield no frames."
            )
            plt.close(fig)  # Close figure before returning
            return

        combined_pos = pd.concat(all_pos_data).dropna(subset=pos_cols)
        if combined_pos.empty:
            warnings.warn(
                f"Position data in columns {pos_cols} is empty or all NaN after combining. Cannot determine limits.\
                    Generator will yield no frames."
            )
            plt.close(fig)  # Close figure before returning
            return

        x_min, x_max = combined_pos[pos_cols[0]].min(), combined_pos[pos_cols[0]].max()
        y_min, y_max = combined_pos[pos_cols[1]].min(), combined_pos[pos_cols[1]].max()
        z_min, z_max = (combined_pos[pos_cols[2]].min(), combined_pos[pos_cols[2]].max()) if is_3d else (None, None)

        x_range = x_max - x_min
        y_range = y_max - y_min
        z_range = (z_max - z_min) if is_3d and z_min is not None and z_max is not None else 0.0

        padding_x = x_range * 0.05 if x_range > 1e-9 else 1.0
        padding_y = y_range * 0.05 if y_range > 1e-9 else 1.0
        padding_z = z_range * 0.05 if is_3d and z_range > 1e-9 else 1.0

        ax_limits = {'xlim': (x_min - padding_x, x_max + padding_x), 'ylim': (y_min - padding_y, y_max + padding_y)}
        if is_3d and z_min is not None and z_max is not None:  # Check z_min/z_max not None
            ax_limits['zlim'] = (z_min - padding_z, z_max + padding_z)

        # --- Colormap and Normalization Setup ---
        cmap_events: Colormap
        try:
            cmap_events = plt.get_cmap(event_cmap)
            max_clid = 0
            if _plot_events and not arcos_data_copy.empty and collid_col in arcos_data_copy:
                valid_clids = arcos_data_copy[collid_col].dropna()
                max_clid = int(valid_clids.max()) if not valid_clids.empty else 0
            num_event_colors = max(20, max_clid + 1)
        except ValueError:
            warnings.warn(f"Event colormap '{event_cmap}' not found. Using default '{DEFAULT_EVENT_CMAP}'.")
            cmap_events = plt.get_cmap(DEFAULT_EVENT_CMAP)
            num_event_colors = cmap_events.N if hasattr(cmap_events, "N") else 20

        cmap_all_cells: Optional[Colormap] = None
        norm_all_cells: Optional[Normalize] = None
        _can_color_all_by_meas = can_color_all_by_meas
        meas_min: Optional[float] = None
        meas_max: Optional[float] = None

        if _can_color_all_by_meas:
            try:
                cmap_all_cells = plt.get_cmap(all_cells_cmap)
                if measurement_min_max:
                    meas_min, meas_max = measurement_min_max
                    if meas_min is None or meas_max is None:
                        warnings.warn("Incomplete 'measurement_min_max' provided. Determining range from data.")
                        meas_min, meas_max = None, None
                if meas_min is None or meas_max is None:
                    valid_meas = all_cells_data_copy[measurement_col].dropna()
                    if not valid_meas.empty:
                        meas_min = valid_meas.min()
                        meas_max = valid_meas.max()
                    else:
                        warnings.warn(
                            f"Could not determine measurement range for {measurement_col}. Falling back to fixed color."
                        )
                        _can_color_all_by_meas = False

                if _can_color_all_by_meas and meas_min is not None and meas_max is not None:  # Check again
                    if abs(meas_max - meas_min) < 1e-9:
                        meas_min -= 0.5
                        meas_max += 0.5
                    norm_all_cells = Normalize(vmin=meas_min, vmax=meas_max)
                    print(
                        f"Coloring 'all cells' by '{measurement_col}' using '{all_cells_cmap}'\
                            cmap (Range: {meas_min:.2f} - {meas_max:.2f})"
                    )
                else:  # Ensure flag is false if range determination failed
                    _can_color_all_by_meas = False

            except ValueError:
                warnings.warn(f"All cells colormap '{all_cells_cmap}' not found. Falling back to fixed color.")
                _can_color_all_by_meas = False
            except Exception as e:
                warnings.warn(f"Error setting up measurement colormap: {e}. Falling back to fixed color.")
                _can_color_all_by_meas = False

        if (
            add_measurement_colorbar
            and _can_color_all_by_meas
            and cmap_all_cells is not None
            and norm_all_cells is not None
        ):
            fig.subplots_adjust(right=0.85)
            cbar_ax = fig.add_axes((0.88, 0.15, 0.03, 0.7))
            sm = cm.ScalarMappable(cmap=cmap_all_cells, norm=norm_all_cells)
            sm.set_array([])
            cbar = fig.colorbar(sm, cax=cbar_ax)
            cbar.set_label(measurement_col or "Measurement")
        else:
            fig.subplots_adjust(right=0.95)

        all_cells_size = point_size * all_cells_marker_size_factor
        bin_cell_size = point_size * bin_cell_marker_factor
        hull_linewidth = point_size * hull_linewidth_size_factor
        event_cell_size = point_size

        # --- Frame Yield Loop ---
        for i, frame in enumerate(frames):
            ax.clear()

            current_arcos_frame = pd.DataFrame()
            current_all_cells_frame = pd.DataFrame()

            if arcos_data_grouped and frame in arcos_data_grouped.groups:
                current_arcos_frame = arcos_data_grouped.get_group(frame)
            if all_cells_grouped and frame in all_cells_grouped.groups:
                current_all_cells_frame = all_cells_grouped.get_group(frame)

            # 1. Plot "all cells" (background)
            if plot_all_cells and not current_all_cells_frame.empty:
                valid_cells = current_all_cells_frame.dropna(subset=pos_cols)
                if _can_color_all_by_meas and measurement_col is not None and measurement_col in valid_cells:
                    valid_cells = valid_cells.dropna(subset=[measurement_col])
                    if not valid_cells.empty and cmap_all_cells is not None and norm_all_cells is not None:
                        measurements = valid_cells[measurement_col].values
                        colors = cmap_all_cells(norm_all_cells(measurements))
                        if is_3d:
                            ax.scatter(  # type: ignore[misc]
                                valid_cells[pos_cols[0]],
                                valid_cells[pos_cols[1]],
                                valid_cells[pos_cols[2]],
                                s=all_cells_size,
                                c=colors,
                                alpha=all_cells_alpha,
                                marker=".",
                            )
                        else:
                            ax.scatter(
                                x=valid_cells[pos_cols[0]],
                                y=valid_cells[pos_cols[1]],
                                s=all_cells_size,
                                c=colors,
                                alpha=all_cells_alpha,
                                marker=".",
                            )
                elif not valid_cells.empty:  # Fallback to fixed color
                    if is_3d:
                        ax.scatter(  # type: ignore[misc]
                            valid_cells[pos_cols[0]],
                            valid_cells[pos_cols[1]],
                            valid_cells[pos_cols[2]],
                            s=all_cells_size,
                            c=all_cells_fixed_color,
                            alpha=all_cells_alpha,
                            marker=".",
                        )
                    else:
                        ax.scatter(
                            x=valid_cells[pos_cols[0]],
                            y=valid_cells[pos_cols[1]],
                            s=all_cells_size,
                            c=all_cells_fixed_color,
                            alpha=all_cells_alpha,
                            marker=".",
                        )

            # 2. Plot "binarized only" cells
            if _plot_bin_cells and not current_arcos_frame.empty and bin_col is not None:
                bin_only_cells = pd.DataFrame()
                if bin_col in current_arcos_frame and collid_col in current_arcos_frame:
                    # Ensure columns exist before filtering
                    bin_mask = current_arcos_frame[bin_col].fillna(0) > 0
                    event_mask = current_arcos_frame[collid_col].fillna(0) <= 0
                    bin_only_cells = current_arcos_frame[event_mask & bin_mask]

                if not bin_only_cells.empty:
                    valid_cells = bin_only_cells.dropna(subset=pos_cols)
                    if not valid_cells.empty:
                        # FIX: Use explicit kwargs for scatter
                        if is_3d:
                            ax.scatter(  # type: ignore[misc]
                                valid_cells[pos_cols[0]],
                                valid_cells[pos_cols[1]],
                                valid_cells[pos_cols[2]],
                                s=bin_cell_size,
                                c=bin_cell_color,
                                alpha=bin_cell_alpha,
                                marker="o",
                            )
                        else:
                            ax.scatter(
                                x=valid_cells[pos_cols[0]],
                                y=valid_cells[pos_cols[1]],
                                s=bin_cell_size,
                                c=bin_cell_color,
                                alpha=bin_cell_alpha,
                                marker="o",
                            )

            # 3. Plot event cells and hulls
            if _plot_events and not current_arcos_frame.empty and collid_col is not None:
                event_cells = pd.DataFrame()
                if collid_col in current_arcos_frame:
                    event_cells = current_arcos_frame[current_arcos_frame[collid_col].fillna(0) > 0]

                if not event_cells.empty:
                    unique_event_ids = event_cells[collid_col].unique()
                    unique_event_ids = unique_event_ids[~np.isnan(unique_event_ids)]  # Remove NaN
                    unique_event_ids = unique_event_ids[unique_event_ids > 0]  # Ensure positive IDs

                    plotted_hulls = []
                    n_cmap_colors = cmap_events.N if hasattr(cmap_events, "N") else num_event_colors

                    for clid in unique_event_ids:
                        event_points_df = event_cells[event_cells[collid_col] == clid].dropna(subset=pos_cols)
                        if event_points_df.empty:
                            continue

                        event_points = event_points_df[pos_cols].values
                        # Ensure color index is valid
                        color_index = int(clid) % n_cmap_colors
                        color = cmap_events(color_index)

                        if is_3d:
                            ax.scatter(  # type: ignore[misc]
                                event_points[:, 0],
                                event_points[:, 1],
                                event_points[:, 2],
                                s=event_cell_size,
                                c=[color],  # Scatter expects color sequence
                                alpha=event_alpha,
                                marker="o",
                            )
                        else:
                            ax.scatter(
                                x=event_points[:, 0],
                                y=event_points[:, 1],
                                s=event_cell_size,
                                c=[color],  # Scatter expects color sequence
                                alpha=event_alpha,
                                marker="o",
                            )

                        if _plot_convex_hulls and not is_3d:
                            if len(event_points) >= 3:
                                try:
                                    hull = ConvexHull(event_points[:, 0:2])
                                    for simplex in hull.simplices:
                                        plotted_hulls.append((event_points[simplex, 0:2], color))
                                except Exception:
                                    pass  # Ignore Qhull errors etc.

                    if _plot_convex_hulls and plotted_hulls and not is_3d:
                        segments = [item[0] for item in plotted_hulls]
                        hull_colors = [item[1] for item in plotted_hulls]
                        lc = LineCollection(segments, colors=hull_colors, linewidths=hull_linewidth, alpha=hull_alpha)
                        ax.add_collection(lc)

            # --- Set consistent limits and labels ---
            ax.set(**ax_limits)
            ax.set_xlabel(pos_cols[0])
            ax.set_ylabel(pos_cols[1])
            if is_3d:
                ax.set_zlabel(pos_cols[2])  # type: ignore[attr-defined]
            ax.set_title(f"Frame: {frame}")

            yield fig

    finally:
        # Close the figure if the generator exits prematurely or normally
        try:
            plt.close(fig)
        except Exception as e:
            warnings.warn(f"Error closing figure: {e}.")


def save_animation_frames(
    arcos_data: pd.DataFrame,
    all_cells_data: pd.DataFrame,
    output_dir: str,
    frame_col: str,
    collid_col: str,
    pos_cols: List[str],
    measurement_col: Optional[str] = None,
    bin_col: Optional[str] = None,
    plot_all_cells: bool = True,
    color_all_cells_by_measurement: bool = True,
    plot_bin_cells: bool = True,
    plot_events: bool = True,
    plot_convex_hulls: bool = True,
    point_size: float = 10.0,
    event_cmap: str = DEFAULT_EVENT_CMAP,
    event_alpha: float = 0.9,
    hull_alpha: float = 0.8,
    hull_linewidth_size_factor: float = 1.0,
    bin_cell_color: str = DEFAULT_BIN_COLOR,
    bin_cell_alpha: float = 0.7,
    bin_cell_marker_factor: float = 0.8,
    all_cells_cmap: str = DEFAULT_ALL_CELLS_CMAP,
    all_cells_fixed_color: str = DEFAULT_ALL_CELLS_FIXED_COLOR,
    all_cells_alpha: float = 0.5,
    all_cells_marker_size_factor: float = 0.2,
    measurement_min_max: Optional[Tuple[float, float]] = None,
    add_measurement_colorbar: bool = True,
    filename_prefix: str = "frame",
    dpi: int = 150,
) -> None:
    """Generates and saves individual frames of a cell activity visualization as PNG images.

    This function acts as a caller for the `yield_animation_frames` generator.
    It handles the iteration over frames, saving each frame to a file with
    appropriate naming and padding, and ensures figures are closed to free memory.

    Parameters
    ----------
    arcos_data : pd.DataFrame
        DataFrame containing cell activity data, potentially including collective
        event IDs (`collid_col`) and binarization status (`bin_col`).
    all_cells_data : pd.DataFrame
        DataFrame containing all cells (or a representative background set)
        for background plotting. Must include `frame_col`, `pos_cols`, and
        `measurement_col` if `color_all_cells_by_measurement` is True.
    output_dir : str
        Directory where the output frames will be saved.
    frame_col : str
        Name of the column indicating the time frame.
    collid_col : str
        Name of the column indicating the collective event ID.
        Values > 0 are treated as events.
    pos_cols : List[str]
        List of column names for spatial coordinates (e.g., ['x', 'y'] or ['x', 'y', 'z']).
    measurement_col : Optional[str], optional
        Name of the column containing the measurement value. REQUIRED if
        `color_all_cells_by_measurement` is True. Used for coloring background cells.
        Default None.
    bin_col : Optional[str], optional
        Name of the column indicating binarized activity (e.g., values > 0 mean
        binarized). Used for `plot_bin_cells`. Default None.
    plot_all_cells : bool, optional
        Whether to plot the background cells from `all_cells_data`. Default True.
    color_all_cells_by_measurement : bool, optional
        If True and `plot_all_cells` is True, color background cells using
        `measurement_col` and `all_cells_cmap`. Requires `measurement_col` to
        be valid in `all_cells_data`. If False or requirements not met, uses
        `all_cells_fixed_color`. Default True.
    plot_bin_cells : bool, optional
        Whether to plot cells marked active by `bin_col` but not part of a
        collective event (`collid_col` <= 0). Requires `bin_col` to be set.
        Default True.
    plot_events : bool, optional
        Whether to plot cells identified as part of collective events
        (`collid_col` > 0). Default True.
    plot_convex_hulls : bool, optional
        Whether to draw convex hulls around collective events (2D only).
        Default True.
    point_size : float, optional
        Base size for plotted points (event cells). Default 10.0.
    event_cmap : str, optional
        Name of the Matplotlib colormap used to assign unique colors to
        different collective event IDs. Default 'tab20'.
    event_alpha : float, optional
        Alpha transparency for event cells. Default 0.9.
    hull_alpha : float, optional
        Alpha transparency for convex hull lines. Default 0.8.
    hull_linewidth_size_factor : float, optional
        Size factor for convex hull line width. Default 1.0.
    bin_cell_color : str, optional
        Color for binarized (non-event) cells. Default 'black'.
    bin_cell_alpha : float, optional
        Alpha transparency for binarized (non-event) cells. Default 0.7.
    bin_cell_marker_factor : float, optional
        Size multiplier for binarized (non-event) cells relative to `point_size`.
        Default 0.8.
    all_cells_cmap : str, optional
        Name of the Matplotlib colormap used for background cells when
        `color_all_cells_by_measurement` is True. Default 'viridis'.
    all_cells_fixed_color : str, optional
        Color for background cells if `color_all_cells_by_measurement` is False
        or requirements are not met. Default 'gray'.
    all_cells_alpha : float, optional
        Alpha transparency for background cells. Default 0.5.
    all_cells_marker_size_factor : float, optional
        Size multiplier for background cells relative to `point_size`. Default 0.2.
    measurement_min_max : Optional[Tuple[float, float]], optional
        Manual min/max values for the measurement colormap normalization. If None,
        the range is determined from `all_cells_data[measurement_col]`. Default None.
    add_measurement_colorbar : bool, optional
        If True and coloring all cells by measurement, add a static colorbar
        to the figure. Default True.
    filename_prefix : str, optional
        Prefix for the output filenames. Default 'frame'.
    dpi : int, optional
        DPI for the saved images. Default 150.
    """
    # --- Setup Output Directory ---
    try:
        os.makedirs(output_dir, exist_ok=True)
        print(f"Saving animation frames to directory: {output_dir}")
    except OSError as e:
        print(f"Error creating output directory '{output_dir}': {e}")
        return  # Cannot proceed without output directory

    # --- Determine Frame Range and Padding (needed for filenames) ---
    # This duplicates a small part of the generator's logic, but is necessary
    # to format filenames correctly *before* the loop starts.
    min_frame_val = float("inf")
    max_frame_val = float("-inf")
    if not arcos_data.empty and frame_col in arcos_data:
        min_frame_val = 0
        max_frame_val = max(max_frame_val, arcos_data[frame_col].max())
    if not all_cells_data.empty and frame_col in all_cells_data:
        min_frame_val = 0
        max_frame_val = max(max_frame_val, all_cells_data[frame_col].max())

    if min_frame_val == float("inf") or max_frame_val == float("-inf"):
        # Generator will also warn, but we add a message here too.
        print("Could not determine frame range from input data. No frames will be saved.")
        return

    num_total_frames = int(max_frame_val) - int(min_frame_val) + 1
    padding_digits = (
        math.ceil(math.log10(max(1, int(max_frame_val)) + 1)) if max_frame_val >= 0 else 1
    )  # Calculate padding based on max frame number

    # --- Instantiate the Generator ---
    frame_generator = _yield_animation_frames(
        arcos_data=arcos_data,
        all_cells_data=all_cells_data,
        frame_col=frame_col,
        collid_col=collid_col,
        pos_cols=pos_cols,
        measurement_col=measurement_col,
        bin_col=bin_col,
        plot_all_cells=plot_all_cells,
        color_all_cells_by_measurement=color_all_cells_by_measurement,
        plot_bin_cells=plot_bin_cells,
        plot_events=plot_events,
        plot_convex_hulls=plot_convex_hulls,
        point_size=point_size,
        event_cmap=event_cmap,
        event_alpha=event_alpha,
        hull_alpha=hull_alpha,
        hull_linewidth_size_factor=hull_linewidth_size_factor,
        bin_cell_color=bin_cell_color,
        bin_cell_alpha=bin_cell_alpha,
        bin_cell_marker_factor=bin_cell_marker_factor,
        all_cells_cmap=all_cells_cmap,
        all_cells_fixed_color=all_cells_fixed_color,
        all_cells_alpha=all_cells_alpha,
        all_cells_marker_size_factor=all_cells_marker_size_factor,
        measurement_min_max=measurement_min_max,
        add_measurement_colorbar=add_measurement_colorbar,
    )

    # --- Iterate, Save, and Close ---
    saved_frame_count = 0
    print(f"Starting frame generation and saving (estimated {num_total_frames} frames)...")

    for fig in tqdm(frame_generator, desc="Saving frames", total=num_total_frames, unit="frame"):
        # Get frame number from the figure title (set by the generator)
        try:
            title = fig.axes[0].get_title()
            # Handle potential variations in title format slightly more robustly
            frame_num_str = title.split(':')[-1].strip()
            frame_num = int(frame_num_str)
        except (IndexError, ValueError, AttributeError) as e:
            warnings.warn(
                f"Could not reliably determine frame number from figure title ('{title}'). Using counter. Error: {e}"
            )
            # Fallback to a simple counter if title parsing fails
            frame_num = saved_frame_count + int(min_frame_val)  # Estimate frame num

        # Construct filename with padding
        frame_filename = f"{filename_prefix}_{frame_num:0{padding_digits}d}.png"
        output_path = os.path.join(output_dir, frame_filename)

        # Save the figure
        try:
            fig.savefig(output_path, dpi=dpi, bbox_inches='tight')
            saved_frame_count += 1
        except Exception as e:
            print(f"\nError saving frame {output_path}: {e}")
        finally:
            # CRITICAL: Close the figure to free memory, regardless of save success
            plt.close(fig)

    print(f"\nFinished saving {saved_frame_count} frames to {output_dir}.")
    if saved_frame_count == 0:
        print("Note: No frames were generated or saved. Check input data and parameters.")
